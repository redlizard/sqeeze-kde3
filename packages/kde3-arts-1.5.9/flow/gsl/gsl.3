.TH "GSL-Functions" 3 "17 May 2002" "BEAST-0.4.1" "BEAST-0.4.1" 
.SH NAME
GSL-Functions \- GSL Function Reference
.SH SYNOPSIS
\fBgsl_thread_wakeup\fP (\fIthread\fP);
.br
\fBgsl_thread_abort\fP (\fIthread\fP);
.br
\fBgsl_thread_queue_abort\fP (\fIthread\fP);
.br
\fBgsl_thread_aborted\fP ();
.br
\fBgsl_thread_sleep\fP (\fImax_msec\fP);
.br
\fBgsl_thread_awake_after\fP (\fItick_stamp\fP);
.br
\fBgsl_thread_awake_before\fP (\fItick_stamp\fP);
.br
\fBgsl_tick_stamp\fP ();
.br
\fBgsl_data_find_block\fP (\fIhandle\fP, \fIn_values\fP, \fIvalues\fP, \fIepsilon\fP);
.br
\fBgsl_module_tick_stamp\fP (\fImodule\fP);
.br
\fBgsl_job_integrate\fP (\fImodule\fP);
.br
\fBgsl_job_discard\fP (\fImodule\fP);
.br
\fBgsl_job_connect\fP (\fIsrc_module\fP, \fIsrc_ostream\fP, \fIdest_module\fP, \fIdest_istream\fP);
.br
\fBgsl_job_disconnect\fP (\fIdest_module\fP, \fIdest_istream\fP);
.br
\fBGslAccessFunc\fP (\fImodule\fP, \fIdata\fP);
.br
\fBgsl_job_access\fP (\fImodule\fP, \fIaccess_func\fP, \fIdata\fP, \fIfree_func\fP);
.br
\fBgsl_flow_job_access\fP (\fImodule\fP, \fItick_stamp\fP, \fIaccess_func\fP, \fIdata\fP, \fIfree_func\fP);
.br
\fBGslPollFunc\fP (\fIdata\fP, \fIn_values\fP, \fItimeout_p\fP, \fIn_fds\fP, \fIfds\fP, \fIrevents_filled\fP);
.br
\fBgsl_job_add_poll\fP (\fIpoll_func\fP, \fIdata\fP, \fIfree_func\fP, \fIn_fds\fP, \fIfds\fP);
.br
\fBgsl_job_remove_poll\fP (\fIpoll_func\fP, \fIdata\fP);
.br
\fBgsl_job_debug\fP (\fIdebug\fP);
.br
\fBgsl_trans_open\fP ();
.br
\fBgsl_trans_add\fP (\fItrans\fP, \fIjob\fP);
.br
\fBgsl_trans_commit\fP (\fItrans\fP);
.br
\fBgsl_trans_dismiss\fP (\fItrans\fP);
.br
\fBgsl_transact\fP (\fIjob\fP, \fI...\fP);
.br
\fBgsl_engine_init\fP (\fIrun_threaded\fP, \fIblock_size\fP, \fIsample_freq\fP, \fIsub_sample_mask\fP);
.br
\fBgsl_engine_wait_on_trans\fP ();
.br
\fBgsl_power2_fftac\fP (\fIn_values\fP, \fIri_values_in\fP, \fIri_values_out\fP);
.br
\fBgsl_power2_fftsc\fP (\fIn_values\fP, \fIri_values_in\fP, \fIri_values_out\fP);
.br
\fBgsl_power2_fftar\fP (\fIn_values\fP, \fIr_values_in\fP, \fIri_values_out\fP);
.br
\fBgsl_power2_fftsr\fP (\fIn_values\fP, \fIri_values_in\fP, \fIr_values_out\fP);
.br
\fBgsl_filter_tscheb2_steepness_db\fP (\fIiorder\fP, \fIc_freq\fP, \fIepsilon\fP, \fIstopband_db\fP);
.br
\fBgsl_filter_tscheb2_steepness\fP (\fIiorder\fP, \fIc_freq\fP, \fIepsilon\fP, \fIresidue\fP);
.br
\fBgsl_filter_butter_lp\fP (\fIiorder\fP, \fIfreq\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.br
\fBgsl_filter_tscheb1_lp\fP (\fIiorder\fP, \fIfreq\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.br
\fBgsl_filter_tscheb2_lp\fP (\fIiorder\fP, \fIfreq\fP, \fIsteepness\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.br
\fBgsl_filter_butter_hp\fP (\fIiorder\fP, \fIfreq\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.br
\fBgsl_filter_tscheb1_hp\fP (\fIiorder\fP, \fIfreq\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.br
\fBgsl_filter_tscheb2_hp\fP (\fIiorder\fP, \fIfreq\fP, \fIsteepness\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.br
\fBgsl_filter_butter_bp\fP (\fIiorder\fP, \fIfreq1\fP, \fIfreq2\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.br
\fBgsl_filter_tscheb1_bp\fP (\fIiorder\fP, \fIfreq1\fP, \fIfreq2\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.br
\fBgsl_filter_tscheb2_bp\fP (\fIiorder\fP, \fIfreq1\fP, \fIfreq2\fP, \fIsteepness\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.br
\fBgsl_filter_butter_bs\fP (\fIiorder\fP, \fIfreq1\fP, \fIfreq2\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.br
\fBgsl_filter_tscheb1_bs\fP (\fIiorder\fP, \fIfreq1\fP, \fIfreq2\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.br
\fBgsl_filter_tscheb2_bs\fP (\fIiorder\fP, \fIfreq1\fP, \fIfreq2\fP, \fIsteepness\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.br
\fBgsl_filter_fir_approx\fP (\fIiorder\fP, \fIfreq\fP, \fIvalue\fP);
.br
\fBgsl_filter_sine_scan\fP (\fIorder\fP, \fIa\fP, \fIb\fP, \fIfreq\fP, \fIn_values\fP);
.br
\fBgsl_engine_garbage_collect\fP ();
.br
\fBgsl_signal_exp2\fP ();
.br
\fBgsl_approx_exp2\fP (\fIex\fP);
.br
\fBgsl_approx_atan1\fP (\fIx\fP);
.br
\fBgsl_approx_atan1_prescale\fP (\fIboost_amount\fP);
.br
\fBgsl_approx_qcircle1\fP (\fIx\fP);
.br
\fBgsl_approx_qcircle2\fP (\fIx\fP);
.br
\fBgsl_approx_qcircle3\fP (\fIx\fP);
.br
\fBgsl_approx_qcircle4\fP (\fIx\fP);
.br
.SH DESCRIPTION
.SS \fBgsl_thread_wakeup\fP (\fIthread\fP);
.PD 0
.IP \fIGslThread*\ thread\fP 19
thread to wake up
.PD 1
.PP
Wake up a currently sleeping thread. In practice, this function simply causes the next call to \fBgsl_thread_sleep()\fP within \fIthread\fP to last for 0 seconds.  
.PD
.SS \fBgsl_thread_abort\fP (\fIthread\fP);
.PD 0
.IP \fIGslThread*\ thread\fP 19
thread to abort
.PD 1
.PP
Abort a currently running thread. This function does not return until the thread in question terminated execution. Note that the thread handle gets invalidated with invocation of \fBgsl_thread_abort()\fP or \fBgsl_thread_queue_abort()\fP.  
.PD
.SS \fBgsl_thread_queue_abort\fP (\fIthread\fP);
.PD 0
.IP \fIGslThread*\ thread\fP 19
thread to abort
.PD 1
.PP
Same as \fBgsl_thread_abort()\fP, but returns as soon as possible, even if thread hasn't stopped execution yet. Note that the thread handle gets invalidated with invocation of \fBgsl_thread_abort()\fP or \fBgsl_thread_queue_abort()\fP.  
.PD
.SS \fBgsl_thread_aborted\fP ();
.PD 0
.IP \fIRETURNS:\fP 11
\fITRUE\fP if the thread should abort execution
.PD 1
.PP
Find out if the currently running thread should be aborted (the thread is supposed to return from its main thread function).  
.PD
.SS \fBgsl_thread_sleep\fP (\fImax_msec\fP);
.PD 0
.IP \fIglong\ \ max_msec\fP 17
maximum amount of milli seconds to sleep (-1 for infinite time)
.IP \fIRETURNS:\fP 17
\fITRUE\fP if the thread should continue execution
.PD 1
.PP
Sleep for the amount of time given. This function may get interrupted by wakeup or abort requests, it returns whether the thread is supposed to continue execution after waking up.  
.PD
.SS \fBgsl_thread_awake_after\fP (\fItick_stamp\fP);
.PD 0
.IP \fIguint64\ \ tick_stamp\fP 21
tick stamp update to trigger wakeup
.PD 1
.PP
Wakeup the currently running thread after the global tick stamp (see \fBgsl_tick_stamp()\fP) has been updated to \fItick_stamp\fP. (If the moment of wakeup has already passed by, the thread is woken up at the next global tick stamp update.)  
.PD
.SS \fBgsl_thread_awake_before\fP (\fItick_stamp\fP);
.PD 0
.IP \fIguint64\ \ tick_stamp\fP 21
tick stamp update to trigger wakeup
.PD 1
.PP
Wakeup the currently running thread upon the last global tick stamp update (see \fBgsl_tick_stamp()\fP) that happens prior to updating the global tick stamp to \fItick_stamp\fP. (If the moment of wakeup has already passed by, the thread is woken up at the next global tick stamp update.)  
.PD
.SS \fBgsl_tick_stamp\fP ();
.PD 0
.IP \fIRETURNS:\fP 11
GSL's execution tick stamp as unsigned 64bit integer
.PD 1
.PP
Retrive the GSL global tick stamp. GSL increments its global tick stamp at certain intervals, by specific amounts (refer to \fBgsl_engine_init()\fP for further details). The tick stamp is a non-wrapping, unsigned 64bit integer greater than 0. Threads can schedule sleep interruptions at certain tick stamps with \fBgsl_thread_awake_after()\fP and \fBgsl_thread_awake_before()\fP. Tick stamp updating occours at GSL engine block processing boundaries, so code that can guarantee to not run across those boundaries (for instance \fBGslProcessFunc()\fP functions) may use the macro \fIGSL_TICK_STAMP\fP to retrive the current tick in a faster manner (not involving mutex locking). See also \fBgsl_module_tick_stamp()\fP.  
.PD
.SS \fBgsl_data_find_block\fP (\fIhandle\fP, \fIn_values\fP, \fIvalues\fP, \fIepsilon\fP);
.PD 0
.IP \fIGslDataHandle*\ handle\fP 25
an open GslDataHandle
.IP \fIguint\ \ \ \ \ \ \ \ \ \ n_values\fP 25
amount of values to look for
.IP \fIconst\ gfloat*\ \ values\fP 25
values to find
.IP \fIgfloat\ \ \ \ \ \ \ \ \ epsilon\fP 25
maximum difference upon comparisions
.IP \fIRETURNS:\fP 25
position of values in data handle or -1
.PD 1
.PP
Find the position of a block of values within a data handle, where all values compare to the reference values with a delta smaller than epsilon.  
.PD
.SS \fBgsl_module_tick_stamp\fP (\fImodule\fP);
.PD 0
.IP \fIGslModule*\ module\fP 19
a GSL engine module
.IP \fIRETURNS:\fP 19
the module's tick stamp, indicating its process status
.PD 1
.PP
Any thread may call this function on a valid engine module. The module specific tick stamp is updated to \fBgsl_tick_stamp()\fP + \fIn_values\fP every time its \fBGslProcessFunc()\fP function was called. See also \fBgsl_tick_stamp()\fP.  
.PD
.SS \fBgsl_job_integrate\fP (\fImodule\fP);
.PD 0
.IP \fIGslModule*\ module\fP 19
The module to integrate
.IP \fIRETURNS:\fP 19
New job suitable for \fBgsl_trans_add()\fP
.PD 1
.PP
Create a new transaction job to integrate \fImodule\fP into the engine.  
.PD
.SS \fBgsl_job_discard\fP (\fImodule\fP);
.PD 0
.IP \fIGslModule*\ module\fP 19
The module to discard
.IP \fIRETURNS:\fP 19
New job suitable for \fBgsl_trans_add()\fP
.PD 1
.PP
Create a new transaction job which removes \fImodule\fP from the engine and destroys it.  
.PD
.SS \fBgsl_job_connect\fP (\fIsrc_module\fP, \fIsrc_ostream\fP, \fIdest_module\fP, \fIdest_istream\fP);
.PD 0
.IP \fIGslModule*\ src_module\fP 25
Module with output stream
.IP \fIguint\ \ \ \ \ \ src_ostream\fP 25
Index of output stream of \fIsrc_module\fP
.IP \fIGslModule*\ dest_module\fP 25
Module with unconnected input stream
.IP \fIguint\ \ \ \ \ \ dest_istream\fP 25
Index of input stream of \fIdest_module\fP
.IP \fIRETURNS:\fP 25
New job suitable for \fBgsl_trans_add()\fP
.PD 1
.PP
Create a new transaction job which connects the ouput stream \fIsrc_ostream\fP of module \fIsrc_module\fP to the input stream \fIdest_istream\fP of module \fIdest_module\fP (it is an error if the input stream is already connected by the time the job is executed).  
.PD
.SS \fBgsl_job_disconnect\fP (\fIdest_module\fP, \fIdest_istream\fP);
.PD 0
.IP \fIGslModule*\ dest_module\fP 25
Module with connected input stream
.IP \fIguint\ \ \ \ \ \ dest_istream\fP 25
Index of input stream of \fIdest_module\fP
.IP \fIRETURNS:\fP 25
New job suitable for \fBgsl_trans_add()\fP
.PD 1
.PP
Create a new transaction job which causes the input stream \fIdest_istream\fP of \fIdest_module\fP to be disconnected (it is an error if the input stream isn't connected by the time the job is executed).  
.PD
.SS \fBGslAccessFunc\fP (\fImodule\fP, \fIdata\fP);
.PD 0
.IP \fI\ module\fP 9
Module to operate on
.IP \fI\ data\fP 9
Accessor data
.PD 1
.PP
The GslAccessFunc is a user supplied callback function which can access a module in times it is not processing. Accessors are usually used to either read out a module's current state, or to modify its state. An accessor may only operate on the \fIdata\fP and the \fImodule\fP passed in to it.  
.PD
.SS \fBgsl_job_access\fP (\fImodule\fP, \fIaccess_func\fP, \fIdata\fP, \fIfree_func\fP);
.PD 0
.IP \fIGslModule*\ \ \ \ \ module\fP 28
The module to access
.IP \fIGslAccessFunc\ \ access_func\fP 28
The accessor function
.IP \fIgpointer\ \ \ \ \ \ \ data\fP 28
Data passed in to the accessor
.IP \fIGslFreeFunc\ \ \ \ free_func\fP 28
Function to free \fIdata\fP
.IP \fIRETURNS:\fP 28
New job suitable for \fBgsl_trans_add()\fP
.PD 1
.PP
Create a new transaction job which will invoke \fIaccess_func\fP on \fImodule\fP with \fIdata\fP when the transaction queue is processed to modify the module's state.  
.PD
.SS \fBgsl_flow_job_access\fP (\fImodule\fP, \fItick_stamp\fP, \fIaccess_func\fP, \fIdata\fP, \fIfree_func\fP);
.PD 0
.IP \fIGslModule*\ \ \ \ \ module\fP 28

.IP \fIguint64\ \ \ \ \ \ \ \ tick_stamp\fP 28

.IP \fIGslAccessFunc\ \ access_func\fP 28

.IP \fIgpointer\ \ \ \ \ \ \ data\fP 28

.IP \fIGslFreeFunc\ \ \ \ free_func\fP 28

.PD 1
.PP

.PD
.SS \fBGslPollFunc\fP (\fIdata\fP, \fIn_values\fP, \fItimeout_p\fP, \fIn_fds\fP, \fIfds\fP, \fIrevents_filled\fP);
.PD 0
.IP \fI\ data\fP 17
Data of poll function
.IP \fI\ n_values\fP 17
Minimum number of values the engine wants to process
.IP \fI\ timeout_p\fP 17
Location of timeout value
.IP \fI\ n_fds\fP 17
Number of file descriptors used for polling
.IP \fI\ fds\fP 17
File descriptors to be used for polling
.IP \fI\ revents_filled\fP 17
Indicates whether \fIfds\fP actually have their ->revents field filled with valid data.
.IP \fIRETURNS:\fP 17
A boolean value indicating whether the engine should process data right now
.PD 1
.PP
The GslPollFunc is a user supplied callback function which can be hooked into the GSL engine. The engine uses the poll functions to determine whether processing of \fIn_values\fP in its module network is necessary. In order for the poll functions to react to extern events, such as device driver status changes, the engine will \fBpoll(2)\fP the \fIfds\fP of the poll function and invoke the callback with \fIrevents_filled\fP==\fITRUE\fP if any of its \fIfds\fP changed state. The callback may also be invoked at other random times with \fIrevents_filled\fP=\fIFALSE\fP. It is supposed to return \fITRUE\fP if network processing is currently necessary, and \fIFALSE\fP if not. If \fIFALSE\fP is returned, \fItimeout_p\fP may be filled with the number of milliseconds the engine should use for polling at maximum.  
.PD
.SS \fBgsl_job_add_poll\fP (\fIpoll_func\fP, \fIdata\fP, \fIfree_func\fP, \fIn_fds\fP, \fIfds\fP);
.PD 0
.IP \fIGslPollFunc\ \ \ \ \ \ poll_func\fP 28
Poll function to add
.IP \fIgpointer\ \ \ \ \ \ \ \ \ data\fP 28
Data of poll function
.IP \fIGslFreeFunc\ \ \ \ \ \ free_func\fP 28
Function to free \fIdata\fP
.IP \fIguint\ \ \ \ \ \ \ \ \ \ \ \ n_fds\fP 28
Number of poll file descriptors
.IP \fIconst\ GslPollFD*\ fds\fP 28
File descriptors to \fBselect(2)\fP or \fBpoll(2)\fP on
.IP \fIRETURNS:\fP 28
New job suitable for \fBgsl_trans_add()\fP
.PD 1
.PP
Create a new transaction job which adds a poll function to the engine. The poll function is used by the engine to determine whether processing is currently necessary.  
.PD
.SS \fBgsl_job_remove_poll\fP (\fIpoll_func\fP, \fIdata\fP);
.PD 0
.IP \fIGslPollFunc\ \ poll_func\fP 24
Poll function to remove
.IP \fIgpointer\ \ \ \ \ data\fP 24
Data of poll function
.IP \fIRETURNS:\fP 24
New job suitable for \fBgsl_trans_add()\fP
.PD 1
.PP
Create a new transaction job which removes a previously inserted poll function from the engine.  
.PD
.SS \fBgsl_job_debug\fP (\fIdebug\fP);
.PD 0
.IP \fIconst\ gchar*\ debug\fP 20
Debug message
.IP \fIRETURNS:\fP 20
New job suitable for \fBgsl_trans_add()\fP
.PD 1
.PP
Create a new transaction job which issues \fIdebug\fP message when the job is executed. This function is meant for debugging purposes during development phase only and shouldn't be used in production code.  
.PD
.SS \fBgsl_trans_open\fP ();
.PD 0
.IP \fIRETURNS:\fP 11
Newly opened empty transaction
.PD 1
.PP
Open up a new transaction to commit jobs to the GSL engine. This function may cause garbage collection (see \fBgsl_engine_garbage_collect()\fP).  
.PD
.SS \fBgsl_trans_add\fP (\fItrans\fP, \fIjob\fP);
.PD 0
.IP \fIGslTrans*\ trans\fP 17
Opened transaction
.IP \fIGslJob*\ \ \ job\fP 17
Job to add
.PD 1
.PP
Append a job to an opened transaction.  
.PD
.SS \fBgsl_trans_commit\fP (\fItrans\fP);
.PD 0
.IP \fIGslTrans*\ trans\fP 17
Opened transaction
.PD 1
.PP
Close the transaction and commit it to the engine. The engine will execute the jobs contained in this transaction as soon as it has completed its current processing cycle. The jobs will be executed in the exact order they were added to the transaction.  
.PD
.SS \fBgsl_trans_dismiss\fP (\fItrans\fP);
.PD 0
.IP \fIGslTrans*\ trans\fP 17
Opened transaction
.PD 1
.PP
Close and discard the transaction, destroy all jobs currently contained in it and do not execute them. This function may cause garbage collection (see \fBgsl_engine_garbage_collect()\fP).  
.PD
.SS \fBgsl_transact\fP (\fIjob\fP, \fI...\fP);
.PD 0
.IP \fI\ job\fP 6
First job
.IP \fI\ ...\fP 6
\fINULL\fP terminated job list
.PD 1
.PP
Convenience function which openes up a new transaction, collects the \fINULL\fP terminated job list passed to the function, and commits the transaction.  
.PD
.SS \fBgsl_engine_init\fP (\fIrun_threaded\fP, \fIblock_size\fP, \fIsample_freq\fP, \fIsub_sample_mask\fP);
.PD 0
.IP \fIgboolean\ \ run_threaded\fP 27

.IP \fIguint\ \ \ \ \ block_size\fP 27
number of values to process block wise
.IP \fIguint\ \ \ \ \ sample_freq\fP 27

.IP \fIguint\ \ \ \ \ sub_sample_mask\fP 27

.PD 1
.PP
Initialize the GSL engine, this function must be called prior to any other engine related function and can only be invoked once. The \fIblock_size\fP determines the amount by which the global tick stamp (see \fBgsl_tick_stamp()\fP) is updated everytime the whole module network completed processing \fIblock_size\fP values.  
.PD
.SS \fBgsl_engine_wait_on_trans\fP ();
.PD 0
.PD 1
.PP
Wait until all pending transactions have been processed by the GSL Engine. This function may cause garbage collection (see \fBgsl_engine_garbage_collect()\fP).  
.PD
.SS \fBgsl_power2_fftac\fP (\fIn_values\fP, \fIri_values_in\fP, \fIri_values_out\fP);
.PD 0
.IP \fI\ n_values\fP 16
Number of complex values
.IP \fI\ ri_values_in\fP 16
Complex sample values [0..n_values*2-1]
.IP \fI\ ri_values_out\fP 16
Complex frequency values [0..n_values*2-1]
.PD 1
.PP
This function performs a decimation in time fourier transformation in forward direction, where the input values are equidistant sampled data, and the output values contain the frequency proportions of the input. The input and output arrays are complex values with real and imaginery portions interleaved, adressable in the range [0..2*n_values-1], where n_values must be a power of two. Frequencies are stored in-order, the K-th output corresponds to the frequency K/n_values. (If you want to interpret negative frequencies, note that the frequencies -K/n_values and (n_values-K)/n_values are equivalent). Note that the transformation is performed out of place, the input array is not modified, and may not overlap with the output array.  
.PD
.SS \fBgsl_power2_fftsc\fP (\fIn_values\fP, \fIri_values_in\fP, \fIri_values_out\fP);
.PD 0
.IP \fI\ n_values\fP 16
Number of complex values
.IP \fI\ ri_values_in\fP 16
Complex frequency values [0..n_values*2-1]
.IP \fI\ ri_values_out\fP 16
Complex sample values [0..n_values*2-1]
.PD 1
.PP
This function performs a decimation in time fourier transformation in backwards direction with normalization. As such, this function represents the counterpart to \fBgsl_power2_fftac()\fP, that is, a value array which is transformed into the frequency domain with \fBgsl_power2_fftac()\fP can be reconstructed by issuing \fBgsl_power2_fftsc()\fP on the transform. Note that the transformation is performed out of place, the input array is not modified, and may not overlap with the output array.  
.PD
.SS \fBgsl_power2_fftar\fP (\fIn_values\fP, \fIr_values_in\fP, \fIri_values_out\fP);
.PD 0
.IP \fI\ n_values\fP 16
Number of complex values
.IP \fI\ r_values_in\fP 16
Real sample values [0..n_values-1]
.IP \fI\ ri_values_out\fP 16
Complex frequency values [0..n_values-1]
.PD 1
.PP
Real valued variant of \fBgsl_power2_fftac()\fP, the input array contains real valued equidistant sampled data [0..n_values-1], and the output array contains the positive frequency half of the complex valued fourier transform. Note, that the complex valued fourier transform H of a purely real valued set of data, satisfies \fBH(-f)\fP = Conj(\fBH(f)\fP), where \fBConj()\fP denotes the complex conjugate, so that just the positive frequency half suffices to describe the entire frequency spectrum. Even so, the resulting n_values/2 complex frequencies are one value off in storage size, but the resulting frequencies \fBH(0)\fP and \fBH(n_values/2)\fP are both real valued, so the real portion of \fBH(n_values/2)\fP is stored in ri_values_out[1] (the imaginery part of \fBH(0)\fP), so that both r_values_in and ri_values_out can be of size n_values. Note that the transformation is performed out of place, the input array is not modified, and may not overlap with the output array.  
.PD
.SS \fBgsl_power2_fftsr\fP (\fIn_values\fP, \fIri_values_in\fP, \fIr_values_out\fP);
.PD 0
.IP \fI\ n_values\fP 15
Number of complex values
.IP \fI\ ri_values_in\fP 15
Complex frequency values [0..n_values-1]
.IP \fI\ r_values_out\fP 15
Real sample values [0..n_values-1]
.PD 1
.PP
Real valued variant of \fBgsl_power2_fftsc()\fP, counterpart to \fBgsl_power2_fftar()\fP, using the same frequency storage format. A real valued data set transformed into the frequency domain with \fBgsl_power2_fftar()\fP can be reconstructed using this function. Note that the transformation is performed out of place, the input array is not modified, and may not overlap with the output array.  
.PD
.SS \fBgsl_filter_tscheb2_steepness_db\fP (\fIiorder\fP, \fIc_freq\fP, \fIepsilon\fP, \fIstopband_db\fP);
.PD 0
.IP \fIunsigned\ int\ \ iorder\fP 27
filter order
.IP \fIdouble\ \ \ \ \ \ \ \ c_freq\fP 27
passband cutoff frequency (0..pi)
.IP \fIdouble\ \ \ \ \ \ \ \ epsilon\fP 27
fall off at passband frequency (0..1)
.IP \fIdouble\ \ \ \ \ \ \ \ stopband_db\fP 27
reduction in stopband in dB (>= 0)
.PD 1
.PP
Calculates the steepness parameter for Tschebyscheff type 2 lowpass filter, based on the ripple residue in the stop band.  
.PD
.SS \fBgsl_filter_tscheb2_steepness\fP (\fIiorder\fP, \fIc_freq\fP, \fIepsilon\fP, \fIresidue\fP);
.PD 0
.IP \fIunsigned\ int\ \ iorder\fP 23
filter order
.IP \fIdouble\ \ \ \ \ \ \ \ c_freq\fP 23
passband cutoff frequency (0..pi)
.IP \fIdouble\ \ \ \ \ \ \ \ epsilon\fP 23
fall off at passband frequency (0..1)
.IP \fIdouble\ \ \ \ \ \ \ \ residue\fP 23
maximum of transfer function in stopband (0..1)
.PD 1
.PP
Calculates the steepness parameter for Tschebyscheff type 2 lowpass filter, based on ripple residue in the stop band.  
.PD
.SS \fBgsl_filter_butter_lp\fP (\fIiorder\fP, \fIfreq\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.PD 0
.IP \fI\ iorder\fP 10
filter order
.IP \fI\ freq\fP 10
cutoff frequency (0..pi)
.IP \fI\ epsilon\fP 10
fall off at cutoff frequency (0..1)
.IP \fI\ a\fP 10
root polynomial coefficients a[0..iorder]
.IP \fI\ b\fP 10
pole polynomial coefficients b[0..iorder]
.PD 1
.PP
Butterworth lowpass filter.  
.PD
.SS \fBgsl_filter_tscheb1_lp\fP (\fIiorder\fP, \fIfreq\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.PD 0
.IP \fI\ iorder\fP 10
filter order
.IP \fI\ freq\fP 10
cutoff frequency (0..pi)
.IP \fI\ epsilon\fP 10
fall off at cutoff frequency (0..1)
.IP \fI\ a\fP 10
root polynomial coefficients a[0..iorder]
.IP \fI\ b\fP 10
pole polynomial coefficients b[0..iorder]
.PD 1
.PP
Tschebyscheff type 1 lowpass filter.  
.PD
.SS \fBgsl_filter_tscheb2_lp\fP (\fIiorder\fP, \fIfreq\fP, \fIsteepness\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.PD 0
.IP \fI\ iorder\fP 12
filter order
.IP \fI\ freq\fP 12
passband cutoff frequency (0..pi)
.IP \fI\ steepness\fP 12
frequency steepness (c_freq * steepness < pi)
.IP \fI\ epsilon\fP 12
fall off at passband frequency (0..1)
.IP \fI\ a\fP 12
root polynomial coefficients a[0..iorder]
.IP \fI\ b\fP 12
pole polynomial coefficients b[0..iorder]
.PD 1
.PP
Tschebyscheff type 2 lowpass filter. To gain a transition band between freq1 and freq2, pass arguements \fIfreq\fP=freq1 and \fIsteepness\fP=freq2/freq1. To specify the transition band width in fractions of octaves, pass \fIsteepness\fP=2^octave_fraction.  
.PD
.SS \fBgsl_filter_butter_hp\fP (\fIiorder\fP, \fIfreq\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.PD 0
.IP \fI\ iorder\fP 10
filter order
.IP \fI\ freq\fP 10
passband frequency (0..pi)
.IP \fI\ epsilon\fP 10
fall off at passband frequency (0..1)
.IP \fI\ a\fP 10
root polynomial coefficients a[0..iorder]
.IP \fI\ b\fP 10
pole polynomial coefficients b[0..iorder]
.PD 1
.PP
Butterworth highpass filter.  
.PD
.SS \fBgsl_filter_tscheb1_hp\fP (\fIiorder\fP, \fIfreq\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.PD 0
.IP \fI\ iorder\fP 10
filter order
.IP \fI\ freq\fP 10
passband frequency (0..pi)
.IP \fI\ epsilon\fP 10
fall off at passband frequency (0..1)
.IP \fI\ a\fP 10
root polynomial coefficients a[0..iorder]
.IP \fI\ b\fP 10
pole polynomial coefficients b[0..iorder]
.PD 1
.PP
Tschebyscheff type 1 highpass filter.  
.PD
.SS \fBgsl_filter_tscheb2_hp\fP (\fIiorder\fP, \fIfreq\fP, \fIsteepness\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.PD 0
.IP \fI\ iorder\fP 12
filter order
.IP \fI\ freq\fP 12
stopband frequency (0..pi)
.IP \fI\ steepness\fP 12
frequency steepness
.IP \fI\ epsilon\fP 12
fall off at passband frequency (0..1)
.IP \fI\ a\fP 12
root polynomial coefficients a[0..iorder]
.IP \fI\ b\fP 12
pole polynomial coefficients b[0..iorder]
.PD 1
.PP
Tschebyscheff type 2 highpass filter.  
.PD
.SS \fBgsl_filter_butter_bp\fP (\fIiorder\fP, \fIfreq1\fP, \fIfreq2\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.PD 0
.IP \fI\ iorder\fP 10
filter order (must be even)
.IP \fI\ freq1\fP 10
stopband end frequency (0..pi)
.IP \fI\ freq2\fP 10
passband end frequency (0..pi)
.IP \fI\ epsilon\fP 10
fall off at passband frequency (0..1)
.IP \fI\ a\fP 10
root polynomial coefficients a[0..iorder]
.IP \fI\ b\fP 10
pole polynomial coefficients b[0..iorder]
.PD 1
.PP
Butterworth bandpass filter.  
.PD
.SS \fBgsl_filter_tscheb1_bp\fP (\fIiorder\fP, \fIfreq1\fP, \fIfreq2\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.PD 0
.IP \fI\ iorder\fP 10
filter order (must be even)
.IP \fI\ freq1\fP 10
stopband end frequency (0..pi)
.IP \fI\ freq2\fP 10
passband end frequency (0..pi)
.IP \fI\ epsilon\fP 10
fall off at passband frequency (0..1)
.IP \fI\ a\fP 10
root polynomial coefficients a[0..iorder]
.IP \fI\ b\fP 10
pole polynomial coefficients b[0..iorder]
.PD 1
.PP
Tschebyscheff type 1 bandpass filter.  
.PD
.SS \fBgsl_filter_tscheb2_bp\fP (\fIiorder\fP, \fIfreq1\fP, \fIfreq2\fP, \fIsteepness\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.PD 0
.IP \fI\ iorder\fP 12
filter order (must be even)
.IP \fI\ freq1\fP 12
stopband end frequency (0..pi)
.IP \fI\ freq2\fP 12
passband end frequency (0..pi)
.IP \fI\ steepness\fP 12
frequency steepness factor
.IP \fI\ epsilon\fP 12
fall off at passband frequency (0..1)
.IP \fI\ a\fP 12
root polynomial coefficients a[0..iorder]
.IP \fI\ b\fP 12
pole polynomial coefficients b[0..iorder]
.PD 1
.PP
Tschebyscheff type 2 bandpass filter.  
.PD
.SS \fBgsl_filter_butter_bs\fP (\fIiorder\fP, \fIfreq1\fP, \fIfreq2\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.PD 0
.IP \fI\ iorder\fP 10
filter order (must be even)
.IP \fI\ freq1\fP 10
passband end frequency (0..pi)
.IP \fI\ freq2\fP 10
stopband end frequency (0..pi)
.IP \fI\ epsilon\fP 10
fall off at passband frequency (0..1)
.IP \fI\ a\fP 10
root polynomial coefficients a[0..iorder]
.IP \fI\ b\fP 10
pole polynomial coefficients b[0..iorder]
.PD 1
.PP
Butterworth bandstop filter.  
.PD
.SS \fBgsl_filter_tscheb1_bs\fP (\fIiorder\fP, \fIfreq1\fP, \fIfreq2\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.PD 0
.IP \fI\ iorder\fP 10
filter order (must be even)
.IP \fI\ freq1\fP 10
passband end frequency (0..pi)
.IP \fI\ freq2\fP 10
stopband end frequency (0..pi)
.IP \fI\ epsilon\fP 10
fall off at passband frequency (0..1)
.IP \fI\ a\fP 10
root polynomial coefficients a[0..iorder]
.IP \fI\ b\fP 10
pole polynomial coefficients b[0..iorder]
.PD 1
.PP
Tschebyscheff type 1 bandstop filter.  
.PD
.SS \fBgsl_filter_tscheb2_bs\fP (\fIiorder\fP, \fIfreq1\fP, \fIfreq2\fP, \fIsteepness\fP, \fIepsilon\fP, \fIa\fP, \fIb\fP);
.PD 0
.IP \fI\ iorder\fP 12
filter order (must be even)
.IP \fI\ freq1\fP 12
passband end frequency (0..pi)
.IP \fI\ freq2\fP 12
stopband end frequency (0..pi)
.IP \fI\ steepness\fP 12
frequency steepness factor
.IP \fI\ epsilon\fP 12
fall off at passband frequency (0..1)
.IP \fI\ a\fP 12
root polynomial coefficients a[0..iorder]
.IP \fI\ b\fP 12
pole polynomial coefficients b[0..iorder]
.PD 1
.PP
Tschebyscheff type 2 bandstop filter.  
.PD
.SS \fBgsl_filter_fir_approx\fP (\fIiorder\fP, \fIfreq\fP, \fIvalue\fP);
.PD 0
.IP \fI\ iorder\fP 9
order of the filter (must be oven, >= 2)
.IP \fI\ freq\fP 9
the frequencies of the transfer function
.IP \fI\ value\fP 9
the desired value of the transfer function
.PD 1
.PP
Approximates a given transfer function with an iorder-coefficient FIR filter. It is recommended to provide enough frequency values, so that \fIn_points\fP >= \fIiorder\fP.  
.PD
.SS \fBgsl_filter_sine_scan\fP (\fIorder\fP, \fIa\fP, \fIb\fP, \fIfreq\fP, \fIn_values\fP);
.PD 0
.IP \fIguint\ \ \ \ \ \ \ \ \ \ order\fP 25
order of the iir filter
.IP \fIconst\ gdouble*\ a\fP 25
root polynomial coefficients of the filter a[0..order]
.IP \fIconst\ gdouble*\ b\fP 25
pole polynomial coefficients of the filter b[0..order]
.IP \fIgdouble\ \ \ \ \ \ \ \ freq\fP 25
frequency to test
.IP \fIguint\ \ \ \ \ \ \ \ \ \ n_values\fP 25
number of samples
.PD 1
.PP
This function sends a sine signal of the desired frequency through an IIR filter, to test the value of the transfer function at a given point. It uses gsl_iir_filter_eval to do so.  Compared to a "mathematical approach" of finding the transfer function, this function makes it possible to see the effects of finite arithmetic during filter evaluation.  The first half of the output signal is not considered, since a lot of IIR filters have a transient phase where also overshoot is possible.  For n_values, you should specify a reasonable large value. It should be a lot larger than the filter order, and large enough to let the input signal become (close to) 1.0 multiple times.  
.PD
.SS \fBgsl_engine_garbage_collect\fP ();
.PD 0
.PD 1
.PP
GSL Engine user thread function. Collects processed jobs and transactions from the engine and frees them, this involves callback invocation of \fBGslFreeFunc()\fP functions, e.g. from \fBgsl_job_access()\fP or \fBgsl_flow_job_access()\fP jobs. This function may only be called from the user thread, as \fBGslFreeFunc()\fP functions are guranteed to be executed in the user thread.  
.PD
.SS \fBgsl_signal_exp2\fP ();
.PD 0
.PD 1
.PP
Deprecated in favour of \fBgsl_approx_exp2()\fP.  
.PD
.SS \fBgsl_approx_exp2\fP (\fIex\fP);
.PD 0
.IP \fIfloat\ \ ex\fP 11
exponent within [-127..127]
.IP \fIRETURNS:\fP 11
y approximating 2^x
.PD 1
.PP
Fast approximation of 2 raised to the power of x. Multiplicative error stays below 8e-6 and aproaches zero for integer values of x (i.e. x - floor (x) = 0).  
.PD
.SS \fBgsl_approx_atan1\fP (\fIx\fP);
.PD 0
.IP \fIregister\ double\ \ x\fP 20

.PD 1
.PP
Fast \fBatan(x)\fP/(PI/2) approximation, with maximum error < 0.01 and \fBgsl_approx_atan1(0)\fP==0, according to the formula: n1 = -0.41156875521951602506487246309908; n2 = -1.0091272542790025586079663559158; d1 = 0.81901156857081841441890603235599; d2 = 1.0091272542790025586079663559158; \fBpositive_atan1(x)\fP = 1 + (n1 * x + n2) / ((1 + d1 * x) * x + d2);  
.PD
.SS \fBgsl_approx_atan1_prescale\fP (\fIboost_amount\fP);
.PD 0
.IP \fI\ boost_amount\fP 15
boost amount between [0..1]
.IP \fIRETURNS:\fP 15
prescale factor for \fBgsl_approx_atan1()\fP
.PD 1
.PP
Calculate the prescale factor for \fBgsl_approx_atan1(x*prescale)\fP from a linear boost factor, where 0.5 amounts to prescale=1.0, 1.0 results in maximum boost and 0.0 results in maximum attenuation.  
.PD
.SS \fBgsl_approx_qcircle1\fP (\fIx\fP);
.PD 0
.IP \fIregister\ double\ \ x\fP 20
x within [0..1]
.IP \fIRETURNS:\fP 20
y for circle approximation within [0..1]
.PD 1
.PP
Fast approximation of the upper right quadrant of a circle. Errors at x=0 and x=1 are zero, for the rest of the curve, the error wasn't minimized, but distributed to best fit the curverture of a quarter circle. The maximum error is below 0.092.  
.PD
.SS \fBgsl_approx_qcircle2\fP (\fIx\fP);
.PD 0
.IP \fIregister\ double\ \ x\fP 20
x within [0..1]
.IP \fIRETURNS:\fP 20
y for circle approximation within [0..1]
.PD 1
.PP
Fast approximation of the upper left quadrant of a circle. Errors at x=0 and x=1 are zero, for the rest of the curve, the error wasn't minimized, but distributed to best fit the curverture of a quarter circle. The maximum error is below 0.092.  
.PD
.SS \fBgsl_approx_qcircle3\fP (\fIx\fP);
.PD 0
.IP \fIregister\ double\ \ x\fP 20
x within [0..1]
.IP \fIRETURNS:\fP 20
y for circle approximation within [0..1]
.PD 1
.PP
Fast approximation of the lower left quadrant of a circle. Errors at x=0 and x=1 are zero, for the rest of the curve, the error wasn't minimized, but distributed to best fit the curverture of a quarter circle. The maximum error is below 0.092.  
.PD
.SS \fBgsl_approx_qcircle4\fP (\fIx\fP);
.PD 0
.IP \fIregister\ double\ \ x\fP 20
x within [0..1]
.IP \fIRETURNS:\fP 20
y for circle approximation within [0..1]
.PD 1
.PP
Fast approximation of the lower right quadrant of a circle. Errors at x=0 and x=1 are zero, for the rest of the curve, the error wasn't minimized, but distributed to best fit the curverture of a quarter circle. The maximum error is below 0.092.  
.PD

